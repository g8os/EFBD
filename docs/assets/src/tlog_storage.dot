digraph {
  label = "tlogStorage";

  node [shape="box", color="blue" style="rounded"]
    backend [label="ardb.Backend"];


  // (*tlogStorage).Get

  node [shape="box", color="blue" style="rounded"]
    tlsGet [label="(*tlogStorage).Get"];
  node [shape="box", color="green" style="rounded"]
    returnGetContent [label="return content"];
  node [shape="box", color="black" style="rounded"]
    cGet [label="(sequenceCache).Get"];
    sGet [label="(Storage).Get"];

  backend -> tlsGet [label="ReadAt/mergeZeroes"];
  tlsGet -> cGet [label="get cached content"];
  cGet -> sGet [label="no cached\nversion available"];
  cGet -> returnGetContent [label="latest cached version"];
  sGet -> returnGetContent [label="latest storage version"];


  // (*tlogStorage).Set

  node [shape="box", color="blue" style="rounded"]
    tlsSet [label="(*tlogStorage).Set"];
  node [shape="box", color="red" style="rounded"]
    failSetContent [label="error"];
  node [shape="box", color="green" style="rounded"]
    successSetContent [label="success"];
  node [shape="box", color="black" style="rounded"]
    sendTransaction [label="send transaction"];
    cSet [label="(sequenceCache).Add"];
  node [shape="diamond", color="black" style="solid"]
    cSetSuccess [label="content written to cache"];

  backend -> tlsSet [label="WriteAt/mergeZeroes"];
  tlsSet -> cSet [label="cache content per sequence"];
  cSet -> failSetContent [label="failed to cache content"];
  cSet -> cSetSuccess;
  cSetSuccess -> sendTransaction [label="send to\nsender's goroutine"];
  sendTransaction -> successSetContent;

  // (*tlogStorage).Delete

  node [shape="box", color="blue" style="rounded"]
    tlsDelete [label="(*tlogStorage).Delete"];

  backend -> tlsDelete [label="WriteZeroesAt"];
  tlsDelete -> tlsSet [label="set nil content"];

  // (*tlogStorage).Merge

  node [shape="box", color="blue" style="rounded"]
    tlsMerge [label="(*tlogStorage).Merge"];
  node [shape="box", color="black" style="rounded"]
    tlsmCGet [label="(sequenceCache).Get"];
    tlsmSGet [label="(Storage).Get"];
    tlsNilGet [label="alloc empty block"];
    tlsMergeContent [label="merge content"];

  backend -> tlsMerge [label="WriteAt"];
  tlsMerge -> tlsmCGet [label="get cached content"];
  tlsmCGet -> tlsmSGet [label="get storage content"];
  tlsmSGet -> tlsNilGet [label="no cached or storage\ncontent available"];
  tlsmCGet -> tlsMergeContent;
  tlsmSGet -> tlsMergeContent;
  tlsNilGet -> tlsMergeContent;
  tlsMergeContent -> tlsSet;


  // (*tlogStorage).Flush

  node [shape="box", color="blue" style="rounded"]
    tlsFlush [label="(*tlogStorage).Flush"];
  node [shape="box", color="black" style="rounded"]
    tlogWaitOrForceFlush [label="wait for sequenceCache.Empty()"];
    sFlush [label="(Storage).Flush"];
  node [shape="box", color="red" style="rounded"]
    failFlush [label="error"];
  node [shape="box", color="green" style="rounded"]
    successFlush [label="success"];

  backend -> tlsFlush [label="Flush"];
  tlsFlush -> tlogWaitOrForceFlush;
  tlogWaitOrForceFlush -> sFlush;
  tlogWaitOrForceFlush -> failFlush [label="tlog flush failed"];
  sFlush -> failFlush [label="storage flush failed"];
  sFlush -> successFlush [label="all is flushed"];

  // (*tlogStorage).Close

  node [shape="box", color="blue" style="rounded"]
    tlsClose [label="(*tlogStorage).Close"];
  node [shape="box", color="black" style="rounded"]
    sClose [label="(storage).Close"];
    loopClose [label="stop background\ngoroutines"];
  node [shape="diamond", color="black" style="solid"]
    notYetClosed [label="not yet closed"];
  node [shape="box", color="red" style="rounded"]
    failClose [label="error"];
  node [shape="box", color="green" style="rounded"]
    successClose [label="success"];

  backend -> tlsClose [label="Close"];
  tlsClose -> failClose [label="already closed"];
  tlsClose -> notYetClosed;
  notYetClosed -> loopClose [label="stop goroutines"];
  loopClose -> sClose [label="close storage"];
  sClose -> failClose;
  sClose -> successClose;

  // (*tlogStorage).GoBackground

  node [shape="box", color="blue" style="rounded"]
    tlsGoBackground [label="(*tlogStorage).GoBackground"];
  node [shape="box", color="black" style="solid"]
    tlsgbWaitGetContent [label="(tlogClient).Recv"];
  node [shape="diamond", color="black" style="solid"]
    notYetSpawned [label="not yet spawned"];
  node [shape="box", color="black" style="rounded"]
    cEvict [label="(sequenceCache).Evict"];
    tlogClose [label="(tlogClient).Close"];
    sgbWriteOrWriteZeroesAt [label="(Storage).Write(Zeroes)At"];
    sgbDelete [label="(Storage).Delete"];
  node [shape="diamond", color="black" style="solid"]
    sgbIsNil [label="is content nil?"];
  node [shape="box", color="red" style="solid"]
    invalidateStorage [label="crash tlogStorage"];
  node [shape="box", color="red" style="rounded"]
    failGoBackground [label="log as error"];

  backend -> tlsGoBackground [label="GoBackground"];
  tlsGoBackground -> notYetSpawned;
  tlsGoBackground -> failGoBackground [label="already spawned"];
  notYetSpawned -> tlogClose [label="defer" style="dashed"];
  notYetSpawned -> tlsgbWaitGetContent [label="start loop"];
  tlsgbWaitGetContent -> tlsgbWaitGetContent [label="RecvOK"];
  tlsgbWaitGetContent -> invalidateStorage [label="FlushFailed\nRecvFailed"];
  tlsgbWaitGetContent -> cEvict [label="FlushOK"];
  cEvict -> sgbIsNil [label="for each block"];
  sgbIsNil -> sgbWriteOrWriteZeroesAt [label="write content/zeroes"];
  sgbIsNil -> sgbDelete [label="delete content"];
  sgbWriteOrWriteZeroesAt -> invalidateStorage [label="content couldn't be written"];
  sgbWriteOrWriteZeroesAt -> tlsgbWaitGetContent [label="wait for\nnext response"];
  sgbDelete -> invalidateStorage [label="content couldn't be deleted"];
  sgbDelete -> tlsgbWaitGetContent [label="wait for\nnext response"];

  // (*tlogStorage).transactionSender

  node [shape="box", color="blue" style="rounded"]
    tlsTransactionSender [label="(*tlogStorage).transactionSender"];
  node [shape="box", color="black" style="solid"]
    tlsgbWaitGetTransaction [label="receive transaction\n to send"];
  node [shape="box", color="black" style="rounded"]
    tlogSend [label="(tlogClient).Send"];
  node [shape="box", color="red" style="solid"]
    senderInvalidateStorage [label="crash tlogStorage"];

  notYetSpawned -> tlsTransactionSender [label="spawn sender goroutine"];
  tlsTransactionSender -> tlsgbWaitGetTransaction [label="start loop"];
  tlsgbWaitGetTransaction -> tlogSend [label="send transaction\nto tlog server"];
  tlogSend -> senderInvalidateStorage [label="failed to\nsend transaction", style="dashed"];
  tlogSend -> tlsgbWaitGetTransaction [label="transaction\nsent"]
}
